"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8045],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>m,MDXProvider:()=>d,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>s});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},a.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=r.createContext({}),s=function(e){return function(n){var t=p(n.components);return r.createElement(e,a({},n,{components:t}))}},p=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(m.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),s=p(t),d=i,h=s["".concat(o,".").concat(d)]||s[d]||u[d]||a;return t?r.createElement(h,c(c({ref:n},m),{},{components:t})):r.createElement(h,c({ref:n},m))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=h;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var m=2;m<a;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},57822:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>m,toc:()=>p});var r=t(83117),i=t(80102),a=(t(67294),t(3905)),o=["components"],c={id:"incremental-mount",title:"Incremental Mount"},l=void 0,m={unversionedId:"deep-dive/incremental-mount",id:"deep-dive/incremental-mount",title:"Incremental Mount",description:"Even though components provide flatter view hierarchies and perform layout off the main thread, the mount operation (creating, recycling and attaching views and drawables) can still have a cost in the UI thread for very complex components, especially for the ones containing many views.",source:"@site/../docs/deep-dive/incremental-mount.md",sourceDirName:"deep-dive",slug:"/deep-dive/incremental-mount",permalink:"/docs/deep-dive/incremental-mount",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/deep-dive/incremental-mount.md",tags:[],version:"current",frontMatter:{id:"incremental-mount",title:"Incremental Mount"}},s={},p=[],d={toc:p};function u(e){var n=e.components,c=(0,i.Z)(e,o);return(0,a.mdx)("wrapper",(0,r.Z)({},d,c,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Even though components provide flatter view hierarchies and perform ",(0,a.mdx)("a",{parentName:"p",href:"/docs/asynchronous-layout"},"layout off the main thread"),", the mount operation (creating, recycling and attaching views and drawables) can still have a cost in the UI thread for very complex components, especially for the ones containing many views.\nSince there's no benefit of maintaining views outside the viewport, Incremental Mount plays a pivotal role in boosting overall performance by ensuring such views are excluded from the view hierarchy."),(0,a.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,a.mdx)("h5",{parentName:"div"},(0,a.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,a.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.mdx)("div",{parentName:"div",className:"admonition-content"},(0,a.mdx)("p",{parentName:"div"},"It is easy to confuse Litho's Incremental Mount feature with similar Android features such as view recycling in a RecyclerView. However, unlike Android's RecyclerView, Incremental Mount operates on a view-by-view resolution, rather than entire list items as in a RecyclerView.\nThis means that unlike with a RecyclerView, when an individual view has exited the viewport, it will be unmounted from the view hierarchy, even if its container is partially visible within the viewport."))),(0,a.mdx)("p",null,"With Incremental Mount enabled (which it is by default), the ",(0,a.mdx)("inlineCode",{parentName:"p"},"LithoView")," will only mount enough content to fill its visible region and unmount (and recycle) components that are no longer visible."),(0,a.mdx)("p",null,(0,a.mdx)("img",{alt:"Incremental Mount Diagram",src:t(26503).Z,width:"575",height:"289"})),(0,a.mdx)("p",null,"When using a prebuilt collection component such as ",(0,a.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," or a ",(0,a.mdx)("a",{parentName:"p",href:"/docs/kotlin/lazycollections/"},"Lazy Collection"),", the framework will seamlessly perform Incremental Mount.\nWhen not using a prebuilt collection component (such as ",(0,a.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/widget/Recycler.html"},"Recycler"),"), or when manually resizing a ",(0,a.mdx)("inlineCode",{parentName:"p"},"LithoView"),"'s container, you can still integrate Incremental Mount in your existing UI implementation."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java"},"myLithoView.notifyVisibleBoundsChanged();\n")),(0,a.mdx)("p",null,"For example, if a ",(0,a.mdx)("inlineCode",{parentName:"p"},"LithoView")," is nested within a custom scrolling container, ",(0,a.mdx)("inlineCode",{parentName:"p"},"myLithoView.notifyVisibleBoundsChanged()")," should be called within a ",(0,a.mdx)("inlineCode",{parentName:"p"},"OnScrollListener"),"."))}u.isMDXComponent=!0},26503:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/incremental-mount-c3788c2981ecf94f60f8a39c43b2452c.png"}}]);