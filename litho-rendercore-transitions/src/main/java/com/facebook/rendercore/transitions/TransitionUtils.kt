/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.facebook.rendercore.transitions

import android.graphics.drawable.Drawable
import com.facebook.litho.Transition
import com.facebook.litho.Transition.BaseTransitionUnitsBuilder
import com.facebook.litho.Transition.RootBoundsTransition
import com.facebook.litho.Transition.TransitionKeyType
import com.facebook.litho.Transition.TransitionUnit
import com.facebook.litho.TransitionId
import com.facebook.litho.TransitionSet
import com.facebook.litho.animation.AnimatedProperty

object TransitionUtils {

  @JvmStatic
  fun applySizeToDrawableForAnimation(drawable: Drawable, width: Int, height: Int) {
    val bounds = drawable.bounds
    drawable.setBounds(bounds.left, bounds.top, bounds.left + width, bounds.top + height)
    if (drawable is BoundsCallback) {
      drawable.onWidthHeightBoundsApplied(width, height)
    }
  }

  @JvmStatic
  fun applyXYToDrawableForAnimation(drawable: Drawable, x: Int, y: Int) {
    val bounds = drawable.bounds
    drawable.setBounds(x, y, bounds.width() + x, bounds.height() + y)
    if (drawable is BoundsCallback) {
      drawable.onXYBoundsApplied(x, y)
    }
  }

  /**
   * Collects info about root component bounds animation, specifically whether it has animations for
   * width and height also [Transition.TransitionUnit] for appear animation if such is defined.
   */
  @JvmStatic
  fun collectRootBoundsTransitions(
      rootTransitionId: TransitionId,
      transition: Transition,
      property: AnimatedProperty,
      outRootBoundsTransition: RootBoundsTransition
  ) {
    when (transition) {
      is TransitionSet -> {
        val children = transition.children
        for (i in children.indices) {
          collectRootBoundsTransitions(
              rootTransitionId, children[i], property, outRootBoundsTransition)
        }
      }
      is TransitionUnit -> {
        if (transition.targets(rootTransitionId) && transition.targetsProperty(property)) {
          outRootBoundsTransition.hasTransition = true
          if (transition.hasAppearAnimation()) {
            outRootBoundsTransition.appearTransition = transition
          }
        }
      }
      is BaseTransitionUnitsBuilder -> {
        val units = transition.transitionUnits
        for (i in units.indices) {
          collectRootBoundsTransitions(
              rootTransitionId, units[i], property, outRootBoundsTransition)
        }
      }
      else -> throw RuntimeException("Unhandled transition type: $transition")
    }
  }

  @JvmStatic
  fun createTransitionId(
      transitionKey: String?,
      transitionKeyType: TransitionKeyType?,
      transitionOwnerKey: String?,
      transitionGlobalKey: String?
  ): TransitionId? {
    @TransitionId.Type val type: Int
    val reference: String?
    val extraData: String?
    if (!transitionKey.isNullOrEmpty()) {
      reference = transitionKey
      when (transitionKeyType) {
        TransitionKeyType.GLOBAL -> {
          type = TransitionId.Type.GLOBAL
          extraData = null
        }
        TransitionKeyType.LOCAL -> {
          type = TransitionId.Type.SCOPED
          extraData = transitionOwnerKey
        }
        else -> throw IllegalArgumentException("Unhandled transition key type $transitionKeyType")
      }
    } else {
      reference = transitionGlobalKey
      type = TransitionId.Type.AUTOGENERATED
      extraData = null
    }
    return reference?.let { TransitionId(type, it, extraData) }
  }

  @JvmStatic
  fun addTransitions(transition: Transition, outList: MutableList<Transition>) {
    if (transition is BaseTransitionUnitsBuilder) {
      outList.addAll(transition.transitionUnits)
    } else {
      outList.add(transition)
    }
  }

  @JvmStatic
  fun setOwnerKey(transition: Transition, ownerKey: String?) {
    when (transition) {
      is TransitionUnit -> transition.setOwnerKey(ownerKey)
      is TransitionSet -> {
        val children = transition.children
        for (index in children.indices.reversed()) {
          setOwnerKey(children[index], ownerKey)
        }
      }
      is BaseTransitionUnitsBuilder -> {
        val units = transition.transitionUnits
        for (index in units.indices.reversed()) {
          units[index].setOwnerKey(ownerKey)
        }
      }
      else -> throw RuntimeException("Unhandled transition type: $transition")
    }
  }

  interface BoundsCallback {
    fun onWidthHeightBoundsApplied(width: Int, height: Int)

    fun onXYBoundsApplied(x: Int, y: Int)
  }
}
