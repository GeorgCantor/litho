"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"mainSidebar":[{"type":"category","label":"What is Litho?","items":[{"type":"link","label":"Motivation","href":"/docs/intro/motivation","docId":"intro/motivation"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Tutorial","items":[{"type":"link","label":"Overview","href":"/docs/tutorial/overview","docId":"tutorial/overview"},{"type":"link","label":"Setting up the Project","href":"/docs/tutorial/project-setup","docId":"tutorial/project-setup"},{"type":"link","label":"Components and Props","href":"/docs/tutorial/first-components","docId":"tutorial/first-components"},{"type":"link","label":"Introducing Layout","href":"/docs/tutorial/introducing-layout","docId":"tutorial/introducing-layout"},{"type":"link","label":"Adding State","href":"/docs/tutorial/adding-state","docId":"tutorial/adding-state"},{"type":"link","label":"Building Lists","href":"/docs/tutorial/building-lists","docId":"tutorial/building-lists"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Main Concepts","items":[{"type":"link","label":"Components","href":"/docs/mainconcepts/components-basics","docId":"mainconcepts/components-basics"},{"type":"link","label":"Types of Props","href":"/docs/mainconcepts/props","docId":"mainconcepts/props"},{"type":"category","label":"Hooks and State","items":[{"type":"link","label":"Introduction to Hooks","href":"/docs/mainconcepts/hooks-intro","docId":"mainconcepts/hooks-intro"},{"type":"link","label":"useState","href":"/docs/mainconcepts/use-state","docId":"mainconcepts/use-state"},{"type":"link","label":"useEffect","href":"/docs/mainconcepts/use-effect","docId":"mainconcepts/use-effect"},{"type":"link","label":"useRef","href":"/docs/mainconcepts/use-ref","docId":"mainconcepts/use-ref"},{"type":"link","label":"useCached","href":"/docs/mainconcepts/use-cached","docId":"mainconcepts/use-cached"},{"type":"link","label":"useErrorBoundary","href":"/docs/mainconcepts/use-error-boundary","docId":"mainconcepts/use-error-boundary"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Layout System with Flexbox","items":[{"type":"link","label":"Layout System with Flexbox","href":"/docs/mainconcepts/flexbox-yoga","docId":"mainconcepts/flexbox-yoga"},{"type":"link","label":"Yoga Playground","href":"/docs/mainconcepts/yoga-playground","docId":"mainconcepts/yoga-playground"},{"type":"link","label":"Flexbox Troubleshooting","href":"/docs/mainconcepts/troubleshooting","docId":"mainconcepts/troubleshooting"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Keys and Component Identity","href":"/docs/mainconcepts/coordinate-state-actions/keys-and-identity","docId":"mainconcepts/coordinate-state-actions/keys-and-identity"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Building lists","items":[{"type":"link","label":"Sections Basics","href":"/docs/sections/start","docId":"sections/start"},{"type":"link","label":"Adding and Adapting the RecyclerCollectionComponent to Your App","href":"/docs/sections/recycler-collection-component","docId":"sections/recycler-collection-component"},{"type":"link","label":"Best Practice and Performance","href":"/docs/sections/best-practices","docId":"sections/best-practices"},{"type":"link","label":"Horizontal Scrolling and Measurement","href":"/docs/sections/hscrolls","docId":"sections/hscrolls"},{"type":"link","label":"API Annotations, events and lifecycles","href":"/docs/sections/api-overview","docId":"sections/api-overview"},{"type":"category","label":"Advanced","items":[{"type":"link","label":"Prefetch and Pagination","href":"/docs/sections/working-ranges","docId":"sections/working-ranges"},{"type":"link","label":"Granular Dependency Injection","href":"/docs/sections/services","docId":"sections/services"},{"type":"link","label":"Mixing with Android Views","href":"/docs/sections/view-support","docId":"sections/view-support"},{"type":"link","label":"Writing Your Own DiffSection","href":"/docs/sections/diff-sections","docId":"sections/diff-sections"},{"type":"link","label":"Sections Implementation Architecture","href":"/docs/sections/architecture","docId":"sections/architecture"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Animations","items":[{"type":"link","label":"Animation Basics","href":"/docs/animations/transition-basics","docId":"animations/transition-basics"},{"type":"link","label":"Types of Transitions","href":"/docs/animations/transition-types","docId":"animations/transition-types"},{"type":"link","label":"Animating All Layout","href":"/docs/animations/transition-all-layout","docId":"animations/transition-all-layout"},{"type":"link","label":"Customizing Transitions","href":"/docs/animations/transition-choreography","docId":"animations/transition-choreography"},{"type":"link","label":"Animating View Properties with Dynamic Props","href":"/docs/animations/dynamic-props","docId":"animations/dynamic-props"},{"type":"category","label":"Advanced","items":[{"type":"link","label":"More Ways to Define Transitions","href":"/docs/animations/transition-definitions","docId":"animations/transition-definitions"},{"type":"link","label":"Transition Key Scoping","href":"/docs/animations/transition-key-types","docId":"animations/transition-key-types"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Visibility","items":[{"type":"link","label":"Handling Visibility","href":"/docs/mainconcepts/coordinate-state-actions/visibility-handling","docId":"mainconcepts/coordinate-state-actions/visibility-handling"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Accessibility","items":[{"type":"link","label":"Making the UI Accessible","href":"/docs/accessibility/accessibility-overview","docId":"accessibility/accessibility-overview"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Testing","items":[{"type":"link","label":"Getting Started","href":"/docs/kotlin/testing-getting-started","docId":"kotlin/testing-getting-started"},{"type":"link","label":"Assertions","href":"/docs/kotlin/testing-assertions","docId":"kotlin/testing-assertions"},{"type":"link","label":"Interactions","href":"/docs/kotlin/testing-actions","docId":"kotlin/testing-actions"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Widgets","items":[{"type":"link","label":"Built-in widgets","href":"/docs/widgets/builtin-widgets","docId":"widgets/builtin-widgets"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Adopting Litho","items":[{"type":"link","label":"Migration Strategies","href":"/docs/kotlin/migration-strategies","docId":"kotlin/migration-strategies"},{"type":"link","label":"Compatibility with Custom Views","href":"/docs/kotlin/custom-view-compat","docId":"kotlin/custom-view-compat"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Codegen APIs","items":[{"type":"link","label":"Introduction","href":"/docs/codegen/overview","docId":"codegen/overview"},{"type":"link","label":"Layout Specs","href":"/docs/codegen/layout-specs","docId":"codegen/layout-specs"},{"type":"link","label":"Mount Specs","href":"/docs/codegen/mount-specs","docId":"codegen/mount-specs"},{"type":"category","label":"Passing Data To Components","items":[{"type":"link","label":"Props in Specs","href":"/docs/codegen/passing-data-to-components/spec-props","docId":"codegen/passing-data-to-components/spec-props"},{"type":"link","label":"TreeProps","href":"/docs/codegen/passing-data-to-components/treeprops","docId":"codegen/passing-data-to-components/treeprops"}],"collapsed":true,"collapsible":true},{"type":"link","label":"State in Specs","href":"/docs/codegen/state-for-specs","docId":"codegen/state-for-specs"},{"type":"link","label":"Events for Specs","href":"/docs/codegen/events-for-specs","docId":"codegen/events-for-specs"},{"type":"link","label":"Triggering Events with Handles","href":"/docs/codegen/trigger-events","docId":"codegen/trigger-events"},{"type":"link","label":"Code generation","href":"/docs/codegen/code-generation","docId":"codegen/code-generation"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Migrating to the Kotlin API","items":[{"type":"link","label":"Intoduction and Setup","href":"/docs/kotlin/kotlin-intro","docId":"kotlin/kotlin-intro"},{"type":"link","label":"KComponent and Props","href":"/docs/kotlin/kotlin-api-basics","docId":"kotlin/kotlin-api-basics"},{"type":"link","label":"Introducing Hooks for State","href":"/docs/kotlin/hooks-for-spec-developers","docId":"kotlin/hooks-for-spec-developers"},{"type":"link","label":"Flexbox Containers","href":"/docs/kotlin/kotlin-flexbox-containers","docId":"kotlin/kotlin-flexbox-containers"},{"type":"link","label":"Event Handling","href":"/docs/kotlin/event-handling","docId":"kotlin/event-handling"},{"type":"link","label":"Cheatsheet","href":"/docs/kotlin/kotlin-api-cheatsheet","docId":"kotlin/kotlin-api-cheatsheet"},{"type":"category","label":"Lazy Collections","items":[{"type":"link","label":"Introduction","href":"/docs/kotlin/lazycollections/","docId":"kotlin/lazycollections/lazycollections"},{"type":"link","label":"Working with Updates","href":"/docs/kotlin/lazycollections/lazycollections-working-with-updates","docId":"kotlin/lazycollections/lazycollections-working-with-updates"},{"type":"link","label":"Layout and Styling","href":"/docs/kotlin/lazycollections/lazycollections-layout","docId":"kotlin/lazycollections/lazycollections-layout"},{"type":"link","label":"Interactions","href":"/docs/kotlin/lazycollections/lazycollections-interactions","docId":"kotlin/lazycollections/lazycollections-interactions"},{"type":"link","label":"Sections Migration Guide","href":"/docs/kotlin/lazycollections/lazycollections-sections-migration","docId":"kotlin/lazycollections/lazycollections-sections-migration"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Tooling","items":[{"type":"category","label":"Debugging","items":[{"type":"link","label":"Debugging Tips","href":"/docs/debugging/debugging-tips","docId":"debugging/debugging-tips"},{"type":"link","label":"Debugging Sections","href":"/docs/debugging/debugging-sections","docId":"debugging/debugging-sections"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer Tools","items":[{"type":"link","label":"Flipper Plugins","href":"/docs/devtools/flipper-plugins","docId":"devtools/flipper-plugins"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Best Practices","items":[{"type":"link","label":"Immutability","href":"/docs/best-practices/immutability","docId":"best-practices/immutability"},{"type":"link","label":"Props vs. State","href":"/docs/best-practices/props-vs-state","docId":"best-practices/props-vs-state"},{"type":"link","label":"Hoisting State","href":"/docs/mainconcepts/coordinate-state-actions/hoisting-state","docId":"mainconcepts/coordinate-state-actions/hoisting-state"},{"type":"link","label":"Communicating Between Components","href":"/docs/mainconcepts/coordinate-state-actions/communicating-between-components","docId":"mainconcepts/coordinate-state-actions/communicating-between-components"},{"type":"link","label":"Coding Style","href":"/docs/best-practices/coding-style","docId":"best-practices/coding-style"}],"collapsed":true,"collapsible":true}]},"docs":{"accessibility/accessibility-overview":{"id":"accessibility/accessibility-overview","title":"Making the UI Accessible","description":"Why Accessibility is important","sidebar":"mainSidebar"},"animations/dynamic-props":{"id":"animations/dynamic-props","title":"Animating View Properties with Dynamic Props","description":"Dynamic props are properties that are applied directly to a View or Drawable. They are updated without computing a layout or remounting. This makes them efficient for use in animations or other dynamic UIs. Dynamic props are initialised and updated using DynamicValue.","sidebar":"mainSidebar"},"animations/transition-all-layout":{"id":"animations/transition-all-layout","title":"Animating All Layout","description":"The Transition method allLayout enables you to easily animate all layout changes without having to assign transitionKeys to all Components:","sidebar":"mainSidebar"},"animations/transition-basics":{"id":"animations/transition-basics","title":"Animation Basics","description":"Introduction","sidebar":"mainSidebar"},"animations/transition-choreography":{"id":"animations/transition-choreography","title":"Customizing Transitions","description":"Litho provides several APIs to customise many aspects of transitions and animate different components together.","sidebar":"mainSidebar"},"animations/transition-definitions":{"id":"animations/transition-definitions","title":"More Ways to Define Transitions","description":"@State Arguments","sidebar":"mainSidebar"},"animations/transition-key-types":{"id":"animations/transition-key-types","title":"Transition Key Scoping","description":"Within the other pages of the \'Animations\' section, you\'ll see that a common approach is used when defining transitions: assigning transition keys and creating transitions, all within a single ComponentSpec.","sidebar":"mainSidebar"},"animations/transition-types":{"id":"animations/transition-types","title":"Types of Transitions","description":"Litho APIs enable you to create animated transitions between two consecutive LayoutStates of the UI. Within this page, those states are referred to as before and after.","sidebar":"mainSidebar"},"annotation-processor-debugging":{"id":"annotation-processor-debugging","title":"Annotation Processor Debugging","description":"Annotation Processor debugging is a three-step process:"},"architecture-overview":{"id":"architecture-overview","title":"Architecture Overview","description":"Core Concepts"},"asynchronous-layout":{"id":"asynchronous-layout","title":"Asynchronous Layout","description":"Immutability and Thread Safety"},"best-practices/coding-style":{"id":"best-practices/coding-style","title":"Coding Style","description":"This page contains Best Practice guidelines for styling your code.","sidebar":"mainSidebar"},"best-practices/immutability":{"id":"best-practices/immutability","title":"Immutability","description":"Components are essentially functions that receive data as parameters and are immutable (cannot be changed). When the props or state of a component change, the framework will create a new component instance with the updated information, because the previous component cannot be mutated.","sidebar":"mainSidebar"},"best-practices/props-vs-state":{"id":"best-practices/props-vs-state","title":"Props vs. State","description":"Litho components have two types of data model: Props and State.","sidebar":"mainSidebar"},"borders":{"id":"borders","title":"Borders","description":"Litho provides extensive support for stylized borders on component layouts. All of the available options are specified through a Border object via a builder pattern."},"cached-values":{"id":"cached-values","title":"Cached Values","description":"The purpose of the Cached Values API is to provide caching within Spec classes, rather than have to repeatedly make an expensive calculation or to use lazy state updates for this purpose."},"codegen":{"id":"codegen","title":"Code Generation","description":"As explained in Writing Components, Litho relies on code generation in order to create Components from Component Specs. This process utilises intermediate ComponentSpec representations called SpecModels, which are immutable java objects."},"codegen/code-generation":{"id":"codegen/code-generation","title":"Code generation","description":"This page covers the old Java Spec API. If you aren\'t using the Spec API, refer to the Components page.","sidebar":"mainSidebar"},"codegen/events-for-specs":{"id":"codegen/events-for-specs","title":"Events for Specs","description":"The framework provides a general-purpose API to connect components through events. Events are declared as a POJO (Plain Old Java Object) with an @Event annotation. By convention, Event class names are suffixed with Event.","sidebar":"mainSidebar"},"codegen/layout-specs":{"id":"codegen/layout-specs","title":"Layout Specs","description":"This page covers the old Java Spec API. If you\'re not using the Spec API, refer to the Components page.","sidebar":"mainSidebar"},"codegen/mount-specs":{"id":"codegen/mount-specs","title":"Mount Specs","description":"A mount spec defines a component that can render views or drawables.","sidebar":"mainSidebar"},"codegen/overview":{"id":"codegen/overview","title":"Introduction","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"codegen/passing-data-to-components/spec-props":{"id":"codegen/passing-data-to-components/spec-props","title":"Props in Specs","description":"This page covers the old Java Spec API. If you\'re not using the Spec API, refer to the Components page.","sidebar":"mainSidebar"},"codegen/passing-data-to-components/treeprops":{"id":"codegen/passing-data-to-components/treeprops","title":"TreeProps","description":"This page covers the old Java Spec API. If you aren\'t using the Spec API, refer to the TreeProps section of the \'Types of Props\' page.","sidebar":"mainSidebar"},"codegen/state-for-specs":{"id":"codegen/state-for-specs","title":"State in Specs","description":"This page introduces the concept of state in a component written using the Java Spec API, namely a @LayoutSpec or @MountSpec.","sidebar":"mainSidebar"},"codegen/trigger-events":{"id":"codegen/trigger-events","title":"Triggering Events with Handles","description":"A Handle is a unique identifier that can be shared with other components by passing it as a @Prop.","sidebar":"mainSidebar"},"common-props":{"id":"common-props","title":"Common Props","description":"This page contains a detailed API reference for the Litho\'s component common props. It assumes you\u2019re familiar with fundamental Litho concepts, such as LayoutSpecs, Props, and State. If you\u2019re not, read them first."},"communicating-with-the-ui":{"id":"communicating-with-the-ui","title":"Scrolling and communicating with the UI","description":"Introduction"},"community-showcase":{"id":"community-showcase","title":"Community Showcase","description":"This is a selection of community contributions to Litho and projects."},"contributing":{"id":"contributing","title":"How to Contribute","description":"The Facebook Litho team would love to have your contributions."},"custom-layout":{"id":"custom-layout","title":"Manual Measurement","description":"Litho relies on Yoga, a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic."},"debugging/debugging-sections":{"id":"debugging/debugging-sections","title":"Debugging Sections","description":"This page acts as a debugging guide that explains how to read the operations performed when an event occurs in a Litho Sections surface with the Flipper Sections plugin. This helps to debug common issues such as unwanted scrolling and items getting re-rendered incorrectly.","sidebar":"mainSidebar"},"debugging/debugging-tips":{"id":"debugging/debugging-tips","title":"Debugging Tips","description":"Flipper","sidebar":"mainSidebar"},"deep-dive/incremental-mount":{"id":"deep-dive/incremental-mount","title":"Incremental Mount","description":"Even though components provide flatter view hierarchies and perform layout off the main thread, the mount operation (creating, recycling and attaching views and drawables) can still have a cost in the UI thread for very complex components, especially for the ones containing many views."},"deep-dive/reconciliation":{"id":"deep-dive/reconciliation","title":"Introduction","description":"Reconciliation is an implementation detail in Litho\u2019s layout calculation process. Instead of recreating the entire layout tree for every update, reconciliation enables Litho to clone the"},"deep-dive/reconciliation/enabling-reconciliation":{"id":"deep-dive/reconciliation/enabling-reconciliation","title":"Enabling Reconciliation","description":"Reconciliation is enabled by default."},"devtools/android-studio-plugin":{"id":"devtools/android-studio-plugin","title":"Android Studio Plugin","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"devtools/flipper-plugins":{"id":"devtools/flipper-plugins","title":"Flipper Plugins","description":"When you create or debug standard Android Views, you can use the \'Layout Preview\' and the \'Layout Inspector\' tools from Android Studio. However, since Litho operates with different UI primitives, such as \'Components\' and \'Sections\', those standard tools are not very useful in such cases.","sidebar":"mainSidebar"},"events-touch-handling":{"id":"events-touch-handling","title":"Touch Handling","description":"All components support touch handling through the framework\'s event system. All components can handle the following events by default: ClickEvent, LongClickEvent, and TouchEvent."},"faq":{"id":"faq","title":"FAQ","description":"Frequently Asked Questions"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"<Tabs"},"glossary":{"id":"glossary","title":"Glossary","description":"Spec? Prop? State? Tree? What do all of these terms mean when it comes to Litho and Section Components?"},"intro":{"id":"intro","title":"What is Litho?","description":"Litho is a declarative framework for building efficient user interfaces (UI) on"},"intro/built-with-litho":{"id":"intro/built-with-litho","title":"Built with Litho","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"intro/motivation":{"id":"intro/motivation","title":"Motivation","description":"Building a list interface on Android is fairly simple. Just create a layout for","sidebar":"mainSidebar"},"kotlin/custom-view-compat":{"id":"kotlin/custom-view-compat","title":"Compatibility with Custom Views","description":"This page details how to migrate custom Views to Litho Components when the existing widgets cannot be composed to achieve the UI you want.","sidebar":"mainSidebar"},"kotlin/event-handling":{"id":"kotlin/event-handling","title":"Event Handling","description":"There are three scenarios in which the use of Event Handlers is different in the Kotlin API:","sidebar":"mainSidebar"},"kotlin/hooks-for-spec-developers":{"id":"kotlin/hooks-for-spec-developers","title":"Introducing Hooks for State","description":"This page covers how to convert existing code from lifecycle methods in the Java Specs API to hooks in the Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-api-basics":{"id":"kotlin/kotlin-api-basics","title":"KComponent and Props","description":"This page details how to convert existing Component with @LayoutSpecs to Kotlin KComponent.","sidebar":"mainSidebar"},"kotlin/kotlin-api-cheatsheet":{"id":"kotlin/kotlin-api-cheatsheet","title":"Cheatsheet","description":"The following cheatsheet provides a set of links for the migration of individual aspects of existing code from the Java Spec API to Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-flexbox-containers":{"id":"kotlin/kotlin-flexbox-containers","title":"Flexbox Containers","description":"This page covers how to convert existing code from the Java Spec API to the Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-intro":{"id":"kotlin/kotlin-intro","title":"Intoduction and Setup","description":"Introduction","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections":{"id":"kotlin/lazycollections/lazycollections","title":"Introduction","description":"A simple, but non-scalable approach to render a list of components is to use a Column or Row container:","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-interactions":{"id":"kotlin/lazycollections/lazycollections-interactions","title":"Interactions","description":"Scrolling the Lazy Collection","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-layout":{"id":"kotlin/lazycollections/lazycollections-layout","title":"Layout and Styling","description":"Spacing","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-sections-migration":{"id":"kotlin/lazycollections/lazycollections-sections-migration","title":"Sections Migration Guide","description":"This page provides guidance for migrating an existing list rendered with Sections to lazy collections. This will involve:","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-working-with-updates":{"id":"kotlin/lazycollections/lazycollections-working-with-updates","title":"Working with Updates","description":"A lazy collection is updated by changing the prop/state values from which it is generated.","sidebar":"mainSidebar"},"kotlin/migration-strategies":{"id":"kotlin/migration-strategies","title":"Migration Strategies","description":"Prerequisites","sidebar":"mainSidebar"},"kotlin/testing-actions":{"id":"kotlin/testing-actions","title":"Interactions","description":"An Interaction is defined as any type of action that a user can perform on Components. A good example is touching or clicking a Button.","sidebar":"mainSidebar"},"kotlin/testing-assertions":{"id":"kotlin/testing-assertions","title":"Assertions","description":"It\'s possible to use AssertJ-style APIs to assert what gets rendered by a Component or LithoView. All of the Component and LithoView assertions are exposed in LithoAssertions.assertThat() methods.","sidebar":"mainSidebar"},"kotlin/testing-getting-started":{"id":"kotlin/testing-getting-started","title":"Getting Started","description":"The Litho Testing API is presented through the LithoViewRule class, it enables the following:","sidebar":"mainSidebar"},"mainconcepts/components-basics":{"id":"mainconcepts/components-basics","title":"Components","description":"What is a component?","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/communicating-between-components":{"id":"mainconcepts/coordinate-state-actions/communicating-between-components","title":"Communicating Between Components","description":"Dispatching an Event from a child to its parent","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/componenttree":{"id":"mainconcepts/coordinate-state-actions/componenttree","title":"ComponentTree","description":"In the Using Components guide, we saw how you can create a root component and pass it to a LithoView, which will take care of creating a ComponentTree with the given root. ComponentTree manages your component\'s lifecycle in a thread-safe way. You can create and make calls to it from any thread."},"mainconcepts/coordinate-state-actions/hoisting-state":{"id":"mainconcepts/coordinate-state-actions/hoisting-state","title":"Hoisting State","description":"Often, several components need to reflect the same changing value. Rather than a state for each component, it is better to host a single state in their closest common ancestor.","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/keys-and-identity":{"id":"mainconcepts/coordinate-state-actions/keys-and-identity","title":"Keys and Component Identity","description":"Explains how Component identity works in Litho using keys and why manual keys are sometimes necessary.","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/visibility-handling":{"id":"mainconcepts/coordinate-state-actions/visibility-handling","title":"Handling Visibility","description":"Describes the APIs to handle visibility of components","sidebar":"mainSidebar"},"mainconcepts/flexbox-yoga":{"id":"mainconcepts/flexbox-yoga","title":"Layout System with Flexbox","description":"Litho uses the Yoga library, which is an implementation of Flexbox, to measure and layout on-screen components. If you have used Flexbox on the web before then this should be very familiar. If you are more familiar with how Android normally performs Layout then Flexbox will remind you of LinearLayout.","sidebar":"mainSidebar"},"mainconcepts/hooks-intro":{"id":"mainconcepts/hooks-intro","title":"Introduction to Hooks","description":"Definition: Hooks are special functions that can persist state across renders and perform side effects . They begin with use and may only be called from render() and other hooks. The API is heavily inspired by React Hooks.","sidebar":"mainSidebar"},"mainconcepts/props":{"id":"mainconcepts/props","title":"Types of Props","description":"The Components page details how to declare a component and its props as standard val properties. This page covers two more ways for a parent component to configure its children with props: Common props and Tree props.","sidebar":"mainSidebar"},"mainconcepts/troubleshooting":{"id":"mainconcepts/troubleshooting","title":"Flexbox Troubleshooting","description":"There are few issues you may face while using flexbox. This section discusses the more common of those issues, which may prove useful when debugging and finding issues in layout.","sidebar":"mainSidebar"},"mainconcepts/use-cached":{"id":"mainconcepts/use-cached","title":"useCached","description":"useCached is a hook that, rather than have to repeatedly make an expensive calculation, enables a component to calculate and maintain a cached value. It is calculated when the component is first added to the ComponentTree, and only recalculated when any of the dependencies provided in the useCached declaration changes.","sidebar":"mainSidebar"},"mainconcepts/use-effect":{"id":"mainconcepts/use-effect","title":"useEffect","description":"useEffect is a hook that allows a component to perform side effects when it\'s attached and/or detached from the tree, or in response to changes in committed props or state.","sidebar":"mainSidebar"},"mainconcepts/use-error-boundary":{"id":"mainconcepts/use-error-boundary","title":"useErrorBoundary","description":"useErrorBoundary enables components to catch and handle errors higher up in the tree and provide appropriate fallback, logging or retry mechanisms.","sidebar":"mainSidebar"},"mainconcepts/use-ref":{"id":"mainconcepts/use-ref","title":"useRef","description":"useRef is a hook that allows a component to maintain a mutable reference that doesn\'t trigger a re-render when updated. It returns an instance of Ref which has a single mutable value property, which should only be read/written on the UI thread.","sidebar":"mainSidebar"},"mainconcepts/use-state":{"id":"mainconcepts/use-state","title":"useState","description":"useState is a hook that allows a component to persist and update a single value across renders and is the most common hook you\'ll encounter.","sidebar":"mainSidebar"},"mainconcepts/yoga-playground":{"id":"mainconcepts/yoga-playground","title":"Yoga Playground","description":"You can use the Yoga Playground to try different layout configurations and generate corresponding Litho code, as shown in the following screenshot.","sidebar":"mainSidebar"},"mount-extensions":{"id":"mount-extensions","title":"Mount Extensions","description":"Mount Extensions are a way of modularising Litho\u2019s default behaviour, as it\u2019s being changed from a monolithic framework to a modular framework that\u2019s split into the rendering engine (RenderCore) and extensions for custom behaviour."},"mountablecomponents/introduction-to-rendercore":{"id":"mountablecomponents/introduction-to-rendercore","title":"Introduction to RenderCore","description":"RenderCore is an abstract framework which is agnostic of the user-facing APIs. RenderCore implements a rendering pipeline for Components-based UI frameworks that provides client frameworks the capability to compute layouts ahead of time in the background, and render them efficiently. Litho uses RenderCore to render Mountable Components."},"mountablecomponents/mountable-component":{"id":"mountablecomponents/mountable-component","title":"Mountable Component","description":"Mountable Components can be used to render views or drawables on the screen."},"mountablecomponents/overview":{"id":"mountablecomponents/overview","title":"Overview","description":"In this section you can find information about Mountable Components, which are a replacement for the old Java Specs API-based Mount Specs - components that can render views or drawables."},"onattached-ondetached":{"id":"onattached-ondetached","title":"OnAttached/OnDetached","description":"Sometimes we would like the component to subscribe a listener when it\'s available and unsubscribe the listener when the component is unavailable. Usually we can use VisibleEvent and InvisibleEvent handlers to subscribe/unsubscribe listeners."},"performance/analysing-performance":{"id":"performance/analysing-performance","title":"Analysing Performance","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"recycling":{"id":"recycling","title":"Recycling","description":"Device screens typically refresh at a rate of 60 frames per second. To provide smooth performances, an app needs to be able to render changes to our UI continuously every 16ms. Failing to respect this time constraint leads to dropped frames and poor user experience."},"repo-structure":{"id":"repo-structure","title":"Repository Structure","description":"This is a quick breakdown of what is where in the repository."},"saving-state":{"id":"saving-state","title":"Saving state on rotation","description":"Saving state on app configuration changes"},"sections-tutorial":{"id":"sections-tutorial","title":"Sections Tutorial","description":"This part builds on the work you did in the litho tutorial. Make sure you\'ve read through that tutorial before returning to this one."},"sections/api-overview":{"id":"sections/api-overview","title":"API Annotations, events and lifecycles","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION","sidebar":"mainSidebar"},"sections/architecture":{"id":"sections/architecture","title":"Sections Implementation Architecture","description":"At its core, the Sections framework is responsible for producing a ChangeSet from immutable props and a hierarchy of Sections. The framework produces these ChangeSets by creating a new section hierarchy whenever a SectionTree is set with a Section with new props, or whenever a Section in the hierarchy updates its internal state when comparing the new hierarchy with the old hierarchy.","sidebar":"mainSidebar"},"sections/best-practices":{"id":"sections/best-practices","title":"Best Practice and Performance","description":"When working with Sections, it is not unfrequent to ask yourself whether what you\u2019re doing is performant, efficient, or idiomatic. The API is short and straightforward, which makes you feel like the problems have to be very subtle and hard to find. The reality is much simpler: Sections is built on top of Android\u2019s RecyclerView and inherits all of its properties, which are common knowledge amongst Android developers. You could build your own if you need to, and it won\u2019t be much different from what Sections gives you today.","sidebar":"mainSidebar"},"sections/diff-sections":{"id":"sections/diff-sections","title":"Writing Your Own DiffSection","description":"This page contains information needed to build your own DiffSection.","sidebar":"mainSidebar"},"sections/hscrolls":{"id":"sections/hscrolls","title":"Horizontal Scrolling and Measurement","description":"Vertical scrolling lists usually fill the width of the screen so it\'s easy to measure them with a fixed size. Working with horizontal scrolling lists (h-scroll) is not always so trivial because different height settings have different performance implications.","sidebar":"mainSidebar"},"sections/recycler-collection-component":{"id":"sections/recycler-collection-component","title":"Adding and Adapting the RecyclerCollectionComponent to Your App","description":"RecyclerView is one of the fundamental building blocks of any Android application that contain a scrolling list of items. Litho recommends using RecyclerCollectionComponent and Sections to build scrolling Lists easily.  These APIs can be used to build apps from simple, homogeneous Lists to complex, heterogeneous Lists backed by multiple data sources, all while taking advantage of features such as background layout and incremental mount.","sidebar":"mainSidebar"},"sections/services":{"id":"sections/services","title":"Granular Dependency Injection","description":"Values such as @Prop flow through Sections before being rendered on-screen. The Sections API sits between your data source and the UI Component to efficiently calculate the changesets you need to render your components. For better performance, you should only do work at the layer where it\'s required.","sidebar":"mainSidebar"},"sections/start":{"id":"sections/start","title":"Sections Basics","description":"The Sections API (see the \'API\' menu) is built on top of Litho. It provides a declarative, composable, and thread-safe API for writing highly optimised List screens.","sidebar":"mainSidebar"},"sections/view-support":{"id":"sections/view-support","title":"Mixing with Android Views","description":"Sections work best when combined with the rendering optimisations that Litho Components offer. However, the API also provides support for rendering Android Views instead of (or along with) Components. This makes the transition to Sections easier; you can still take advantage of the performance benefits regardless of your product\'s UI using traditional Android Views, Litho Components or a mix of the two.","sidebar":"mainSidebar"},"sections/working-ranges":{"id":"sections/working-ranges","title":"Prefetch and Pagination","description":"The Working Ranges API (see the \'API\' menu) provides the means to perform complex operations such as data prefetching and cache warming.","sidebar":"mainSidebar"},"styles":{"id":"styles","title":"Styles","description":"Components can have their props come from regular Android style resources in a similar way to an Android View\'s AttributeSet constructor. It enables developers to define static prop values or prop defaults directly from style resources."},"testing/espresso-testing":{"id":"testing/espresso-testing","title":"End-to-End Tests","description":"Litho provides basic support for the"},"testing/event-handler-testing":{"id":"testing/event-handler-testing","title":"Event Handler Testing","description":"This document provides a quick example of how to write tests for your event"},"testing/injectprop-matching":{"id":"testing/injectprop-matching","title":"Matching @InjectProp","description":"For help with setting up the test environment, see the Getting Started page."},"testing/prop-matching":{"id":"testing/prop-matching","title":"Matching @Prop","description":"For help with setting up the Test environment, see the Getting Started page."},"testing/sections-testing":{"id":"testing/sections-testing","title":"Testing Sections","description":"The SectionsTestHelper provides easy-to-use helper functions to test the output of GroupSectionSpecs and state updates."},"testing/subcomponent-testing":{"id":"testing/subcomponent-testing","title":"Sub-Component Testing","description":"The Getting Started page contains information to help you setup your test environment."},"testing/testing-overview":{"id":"testing/testing-overview","title":"Introduction","description":"This page contains a brief overview of the variety of tools, provided by Litho, to write different types of tests."},"testing/testing-treeprops":{"id":"testing/testing-treeprops","title":"Matching @TreeProp","description":"For help with setting up the test environment, see the Getting Started page."},"testing/tests-in-android-studio":{"id":"testing/tests-in-android-studio","title":"Testing in Android Studio","description":"The Litho repository can be used with both Buck and Gradle. The Buck plugin for"},"testing/unit-testing":{"id":"testing/unit-testing","title":"Getting Started","description":"To use any of the testing utilities, include the litho-testing package in your build."},"tooltips":{"id":"tooltips","title":"Tooltips","description":"Litho tooltip APIs provide methods for displaying a floating view anchored to a component in your hierarchy."},"tutorial":{"id":"tutorial","title":"Tutorial","description":"This tutorial assumes you\'ve gone through the Getting Started guide to set up Litho.  Make sure you set up Litho\'s core libraries and Sections\' libraries."},"tutorial/adding-state":{"id":"tutorial/adding-state","title":"Adding State","description":"In this section of the tutorial, you\'ll learn about useState, one of Litho\'s Hooks.","sidebar":"mainSidebar"},"tutorial/building-lists":{"id":"tutorial/building-lists","title":"Building Lists","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION","sidebar":"mainSidebar"},"tutorial/first-components":{"id":"tutorial/first-components","title":"Components and Props","description":"In this section of the tutorial, you\'ll learn the basic Litho building blocks then create your first component that uses props.","sidebar":"mainSidebar"},"tutorial/introducing-layout":{"id":"tutorial/introducing-layout","title":"Introducing Layout","description":"In this section of the tutorial, you\'ll become familiar with building layouts using Flexbox in Litho for an Instagram post component.","sidebar":"mainSidebar"},"tutorial/overview":{"id":"tutorial/overview","title":"Overview","description":"This tutorial doesn\u2019t assume you have existing Litho knowledge.","sidebar":"mainSidebar"},"tutorial/project-setup":{"id":"tutorial/project-setup","title":"Setting up the Project","description":"After creating an Android app project in Android Studio, take the steps detailed in this page to configure it with the correct settings and dependencies.","sidebar":"mainSidebar"},"updating-ui":{"id":"updating-ui","title":"Updating the UI","description":"Components and immutability"},"uses":{"id":"uses","title":"Uses","description":"Litho\'s primary use case is RecyclerViews with complex content as it delivers"},"using-components":{"id":"using-components","title":"Using Components","description":"Generated component classes provide a simple builder with the props you defined in your component spec. In order to use the generated component in your UI, you\'ll need a LithoView, which is an Android ViewGroup that is able to render components."},"view-flattening":{"id":"view-flattening","title":"View Flattening","description":"Let\'s take a look at the layout in the example below. It contains an image, a title and subtitle. With the traditional Android View system, you would have a view for all these elements, wrapped in a few view groups for arranging the items."},"widgets/builtin-widgets":{"id":"widgets/builtin-widgets","title":"Built-in widgets","description":"This page covers the basic built-in widgets. You can find the full list of components and APIs within the com.facebook.litho.widget package in javadocs.","sidebar":"mainSidebar"},"writing-components":{"id":"writing-components","title":"Writing Components","description":"Component Specs"}}}')}}]);